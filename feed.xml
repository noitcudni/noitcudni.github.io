<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://noitcudni.github.io/' rel='self' type='application/rss+xml'/>
<title>
(polymorphic-labs/blog)
</title>
<link>
https://noitcudni.github.io/
</link>
<description>
Programming related stuff
</description>
<lastBuildDate>
Sun, 25 Nov 2018 21:03:53 -0800
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://noitcudni.github.io/posts-output/2018-10-22-bulk-google-webmaster-outdated-content-removal/
</guid>
<link>
https://noitcudni.github.io/posts-output/2018-10-22-bulk-google-webmaster-outdated-content-removal/
</link>
<title>
Chrome Extension: Bulk Google Webmaster Outdated Content Removal
</title>
<description>
&lt;p&gt;My little &lt;a href='https://github.com/noitcudni/google-webmaster-tools-bulk-url-removal'&gt;Google Webmaster Tool Bulk URL Removal chrome extension&lt;/a&gt; has gained quite a bit of usage. Several of those users have brought to my attention that Google Webmaster Tools also provides a way to remove outdated content, but it has a similar shortcoming: you can only remove outdated URLs one at a time. Recently, after wrapping up another side project, I decided to take a quick stab at this. You can find my extension here: &lt;a href='https://github.com/noitcudni/google-webmaster-tools-bulk-outdated-content-removal'&gt;https://github.com/noitcudni/google-webmaster-tools-bulk-outdated-content-removal&lt;/a&gt;.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Download the zip from github&lt;img src=&quot;//img/github-download-zip.png&quot; alt=&quot;Download the zip file from github&quot; /&gt;&lt;/li&gt;&lt;li&gt;Unzip it somewhere.&lt;/li&gt;&lt;li&gt;Go to &lt;code&gt;chrome://extensions/&lt;/code&gt; inside your chrome browser and turn on developer mode.&lt;/li&gt;&lt;li&gt;Click on &lt;code&gt;Load unpacked extension&lt;/code&gt; and load the extension.&lt;/li&gt;&lt;li&gt;Create a CSV file with the outdated URLs. For example:&lt;pre&gt;&lt;code&gt;http://out.dated.1.com/?foo=bar
http://out.dated.1.com/?foo=baz
http://out.dated.2.com/?foo=baz
&lt;/li&gt;&lt;/ul&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;Go to https://www.google.com/webmasters/tools/removals and you should now have a &quot;Upload Your File&quot; button. Please note that the extension button next to your address bar doesn't do anything, so don't click on it. Click on the &quot;Upload Your File&quot; button and select the csv file you created in step 5.&lt;img src=&quot;//img/upload-your-file-screenshot.png&quot; alt=&quot;Upload your file to start bulk outdated content removals&quot; /&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
<pubDate>
Mon, 22 Oct 2018 00:00:00 -0700
</pubDate>
</item>
<item>
<guid>
https://noitcudni.github.io/posts-output/2018-01-13-reagent-d3-force-directed-graph/
</guid>
<link>
https://noitcudni.github.io/posts-output/2018-01-13-reagent-d3-force-directed-graph/
</link>
<title>
Force-directed graph with D3js in Clojurescript
</title>
<description>
&lt;p&gt;Recently, I stumbled upon opensecrets.org where I could get a hold of raw data on US Senate and House campaign contributions. Full disclosure, I don't consider myself very political, nor do I know the interworkings of our political system, but I thought why not graph the contribution data in d3js.&lt;/p&gt;&lt;p&gt;I have done a couple d3js projects in the past in Javascript, but I really don't want to code in Javascript if I can help it. After some googling, I found &lt;a href='https://github.com/gadfly361/rid3'&gt;rid3&lt;/a&gt;, a clojurescript library on top of d3 and Reagent, and decided to give it a spin. I'm going to assume that you already have a working knowledge of reagent and re-frame.&lt;/p&gt;&lt;h3 id=&quot;setup&quot;&gt;Setup&lt;/h3&gt;&lt;p&gt;Add two additional dependencies to your project.clj. We're going to using re-frame for our state management.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defproject viz &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :dependencies &amp;#91;&amp;#91;org.clojure/clojure &amp;quot;1.8.0&amp;quot;&amp;#93;
                 &amp;#91;org.clojure/clojurescript &amp;quot;1.9.908&amp;quot;&amp;#93;
                 &amp;#91;reagent &amp;quot;0.7.0&amp;quot;&amp;#93;
                 &amp;#91;re-frame &amp;quot;0.10.2&amp;quot;&amp;#93; ;; &amp;lt;-- add this
                 &amp;#91;rid3 &amp;quot;0.2.0&amp;quot;&amp;#93;&amp;#93;  ;; &amp;lt;-- add this
                 ...
                 &amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;test&amp;#95;data&quot;&gt;Test data&lt;/h3&gt;&lt;p&gt;Apparently, there's a lot of data around campaign contributions. Instead of dealing with a large data set right off the bat while trying to get a d3 force-directed graph working in clojurescript, I decided it'd be wise to create a small data sample in order to iterate quickly.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; in db.cljs
&amp;#40;def default-db
  {:name &amp;quot;re-frame name&amp;quot;
   :test-data {:dataset
               {:nodes
                &amp;#91;{ :id &amp;quot;mammal&amp;quot; :group 0  :label &amp;quot;Mammals&amp;quot; :level 1 }
                 { :id &amp;quot;dog&amp;quot;    :group 0  :label &amp;quot;Dogs&amp;quot;    :level 2 }
                 { :id &amp;quot;cat&amp;quot;    :group 0  :label &amp;quot;Cats&amp;quot;    :level 2 }
                 { :id &amp;quot;fox&amp;quot;    :group 0  :label &amp;quot;Foxes&amp;quot;   :level 2 }
                 { :id &amp;quot;elk&amp;quot;    :group 0  :label &amp;quot;Elk&amp;quot;     :level 2 }
                 { :id &amp;quot;insect&amp;quot; :group 1  :label &amp;quot;Insects&amp;quot; :level 1 }
                 { :id &amp;quot;ant&amp;quot;    :group 1  :label &amp;quot;Ants&amp;quot;    :level 2 }
                 { :id &amp;quot;bee&amp;quot;    :group 1  :label &amp;quot;Bees&amp;quot;    :level 2 }
                 { :id &amp;quot;fish&amp;quot;   :group 2  :label &amp;quot;Fish&amp;quot;    :level 1 }
                 { :id &amp;quot;carp&amp;quot;   :group 2  :label &amp;quot;Carp&amp;quot;    :level 2 }
                 { :id &amp;quot;pike&amp;quot;   :group 2  :label &amp;quot;Pikes&amp;quot;   :level 2 }&amp;#93;
                :links
                &amp;#91;{ :target &amp;quot;mammal&amp;quot; :source &amp;quot;dog&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;mammal&amp;quot; :source &amp;quot;cat&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;mammal&amp;quot; :source &amp;quot;fox&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;mammal&amp;quot; :source &amp;quot;elk&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;insect&amp;quot; :source &amp;quot;ant&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;insect&amp;quot; :source &amp;quot;bee&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;fish&amp;quot;   :source &amp;quot;carp&amp;quot; :strength 0.7 }
                 { :target &amp;quot;fish&amp;quot;   :source &amp;quot;pike&amp;quot; :strength 0.7 }
                 { :target &amp;quot;cat&amp;quot;    :source &amp;quot;elk&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;carp&amp;quot;   :source &amp;quot;ant&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;elk&amp;quot;    :source &amp;quot;bee&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;dog&amp;quot;    :source &amp;quot;cat&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;fox&amp;quot;    :source &amp;quot;ant&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;pike&amp;quot;   :source &amp;quot;dog&amp;quot;  :strength 0.1 }
                 &amp;#93;}}}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we'll need to subscribe to the data, so we have a way to get a hold of it. In &lt;code&gt;subs.cljs&lt;/code&gt;, add a new subscription.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;re-frame/reg-sub
 ::data
 &amp;#40;fn &amp;#91;db&amp;#93;
   &amp;#40;:test-data db&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;empty&amp;#95;canvas&quot;&gt;Empty Canvas&lt;/h3&gt;&lt;p&gt;In your views.cljs, create a &lt;code&gt;force-viz&lt;/code&gt; reagent component and render it inside the &lt;code&gt;main-panel&lt;/code&gt; function. Before rendering &lt;code&gt;force-viz&lt;/code&gt;, we'll also need to subscribe to &lt;code&gt;&amp;#91;::subs/data&amp;#93;&lt;/code&gt; and pass the result along.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn force-viz &amp;#91;ratom&amp;#93;
  &amp;#91;rid3/viz
    {:id &amp;quot;force&amp;quot;
     :ratom ratom
     :svg {:did-mount &amp;#40;fn &amp;#91;node ratom&amp;#93;
                        &amp;#40;-&amp;gt; node
                            &amp;#40;.attr &amp;quot;width&amp;quot; 1000&amp;#41;
                            &amp;#40;.attr &amp;quot;height&amp;quot; 1000&amp;#41;
                            &amp;#40;.style &amp;quot;background-color&amp;quot; &amp;quot;grey&amp;quot;&amp;#41;&amp;#41;&amp;#41;}
    }&amp;#93;&amp;#41;

&amp;#40;defn main-panel &amp;#91;&amp;#93;
  &amp;#40;fn &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;data &amp;#40;re-frame/subscribe &amp;#91;::subs/data&amp;#93;&amp;#41;&amp;#93;
      &amp;#91;force-viz data&amp;#93;
      &amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This creates a big empty 1000 x 1000 canvas. Nothing too interesting at the moment. Let's make the width and height dynamically grow with the browser window. This is where &lt;code&gt;reagent&lt;/code&gt; really shines. On window resize, we are going to set the new height and width via &lt;code&gt;re-frame&lt;/code&gt;. If we have our &lt;code&gt;re-frame&lt;/code&gt; dispatch calls set up properly, our previous &lt;code&gt;re-frame&lt;/code&gt; subscription will automatically include the updated width and height dimensions.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;re-frame/reg-event-fx
 :window-width
 &amp;#40;fn &amp;#91;{:keys &amp;#91;db&amp;#93;} &amp;#91;&amp;#95; width&amp;#93;&amp;#93;
   {:db &amp;#40;-&amp;gt; db
            &amp;#40;assoc-in &amp;#91;:test-data :width&amp;#93; width&amp;#41;&amp;#41;}&amp;#41;&amp;#41;

;; I'll leave out the :window-height dispatch.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inside our &lt;code&gt;init&lt;/code&gt; function in &lt;code&gt;core.cljs&lt;/code&gt;, invoke &lt;code&gt;re-frame&lt;/code&gt; dispatch with the new dimensions.&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;set! js/window.onresize &amp;#40;fn &amp;#91;&amp;#93;
                             &amp;#40;re-frame/dispatch &amp;#91;:window-width js/window.innerWidth&amp;#93;&amp;#41;
                             &amp;#40;re-frame/dispatch &amp;#91;:window-height js/window.innerHeight&amp;#93;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;Don't forget to get rid of the hardcoded 1000x1000 pixels.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn force-viz &amp;#91;ratom&amp;#93;
  &amp;#91;rid3/viz
   {:id &amp;quot;force&amp;quot;
    :ratom ratom
    :svg {:did-mount &amp;#40;fn &amp;#91;node ratom&amp;#93;
                       &amp;#40;.log js/console &amp;quot;here? &amp;quot; &amp;#40;pr-str @ratom&amp;#41;&amp;#41;
                       &amp;#40;-&amp;gt; node
                           &amp;#40;.attr &amp;quot;width&amp;quot; &amp;#40;:width @ratom&amp;#41;&amp;#41;  &amp;lt;-- change here
                           &amp;#40;.attr &amp;quot;height&amp;quot; &amp;#40;:height @ratom&amp;#41;&amp;#41; &amp;lt;-- change here
                           &amp;#40;.style &amp;quot;background-color&amp;quot; &amp;quot;grey&amp;quot;&amp;#41;&amp;#41;&amp;#41;
          }}
    :pieces
    &amp;#91;
    ... ;; &amp;lt;--- more on this below
    &amp;#93;
          &amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now whenever &lt;code&gt;ratom&lt;/code&gt; changes, &lt;code&gt;force-viz&lt;/code&gt; will be rendered automatically.&lt;/p&gt;&lt;h3 id=&quot;let's&amp;#95;draw&amp;#95;some&amp;#95;nodes&amp;#95;and&amp;#95;edges&quot;&gt;Let's draw some nodes and edges&lt;/h3&gt;&lt;p&gt;Quick background. There are 4 types of &lt;code&gt;:pieces&lt;/code&gt; in rid3: &lt;code&gt;elem&lt;/code&gt;, &lt;code&gt;elem-with-data&lt;/code&gt;, &lt;code&gt;container&lt;/code&gt;, and &lt;code&gt;raw&lt;/code&gt;. The order of execution is sequential from top to bottom in &lt;code&gt;:pieces&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;In most cases, bootstrapping and updating in d3 are done in the same manner. By default, rid3's &lt;code&gt;did-update&lt;/code&gt; lifecycle does the same thing as &lt;code&gt;did-mount&lt;/code&gt; unless you tell it otherwise. However, it's worth noting that you have to supply both &lt;code&gt;:did-mount&lt;/code&gt; and &lt;code&gt;:did-update&lt;/code&gt; for the &lt;code&gt;:raw&lt;/code&gt; piece.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; pieces
&amp;#91;{:kind :elem-with-data
  :tag &amp;quot;circle&amp;quot;
  :class &amp;quot;node&amp;quot;
  :did-mount &amp;#40;fn &amp;#91;node ratom&amp;#93;
               &amp;#40;let &amp;#91;r &amp;#40;-&amp;gt; node
                           &amp;#40;.attr &amp;quot;r&amp;quot; &amp;#40;fn &amp;#91;d&amp;#93;
                                        5&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;fill&amp;quot; &amp;#40;fn &amp;#91;n&amp;#93;
                                           &amp;quot;red&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#93;
                 &amp;#40;re-frame/dispatch-sync &amp;#91;:set-var :node-elems r&amp;#93;&amp;#41;&amp;#41;&amp;#41;
  :prepare-dataset &amp;#40;fn &amp;#91;ratom&amp;#93;
                     &amp;#40;-&amp;gt; @ratom
                         &amp;#40;get :dataset&amp;#41;
                         &amp;#40;get :nodes&amp;#41;
                         clj-&amp;gt;js&amp;#41;&amp;#41;}

 {:kind :elem-with-data
  :tag &amp;quot;line&amp;quot;
  :class &amp;quot;link&amp;quot; ;;TODO customize link class
  :did-mount &amp;#40;fn &amp;#91;node ratom&amp;#93;
               &amp;#40;let &amp;#91;r &amp;#40;-&amp;gt; node
                           &amp;#40;.attr &amp;quot;stroke-width&amp;quot; 1&amp;#41;
                           &amp;#40;.attr &amp;quot;stroke&amp;quot; &amp;quot;#E5E5E5&amp;quot;&amp;#41;
                           &amp;#41;&amp;#93;
                 &amp;#40;re-frame/dispatch-sync &amp;#91;:set-var :link-elems r&amp;#93;&amp;#41;&amp;#41;&amp;#41;
  :prepare-dataset &amp;#40;fn &amp;#91;ratom&amp;#93;
                     &amp;#40;-&amp;gt; @ratom
                         &amp;#40;get :dataset&amp;#41;
                         &amp;#40;get :links&amp;#41;
                         clj-&amp;gt;js&amp;#41;&amp;#41;}

 &amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead of dealing with &lt;code&gt;enter&amp;#40;&amp;#41;&lt;/code&gt;, &lt;code&gt;exit&amp;#40;&amp;#41;&lt;/code&gt;, and binding the appropriate piece of data to a selected group of svg objects, most of the heavy lifting has already been done for us. We can turn our focus to how we'd like to represent the information. Since we have a nested structure in our data, we'll have to supply &lt;code&gt;:prepare-dataset&lt;/code&gt;. Hopefully, you would agree that it's pretty trivial.&lt;/p&gt;&lt;p&gt;In Javascript, one could create a bunch of node and link elements, assign them to their respective variables, and refer to them later when necessary. Spoiler alert, we'll need to somehow pass our newly constructed nodes and links to &lt;code&gt;d3.forceSimulation&lt;/code&gt; to kickstart the force directed graph. At first glance, there's no way of doing that with rid3. Don't despair. We can stash the node elements and the link elements via re-frame and get them back later. Hence, the &lt;code&gt;re-frame/dispatch-sync&lt;/code&gt; calls. Note that we'll need to call &lt;code&gt;dispatch-sync&lt;/code&gt; here and not &lt;code&gt;dispatch&lt;/code&gt; since we want to make sure that both node and link elements are done storing before going forward.&lt;/p&gt;&lt;p&gt;The implementation of &lt;code&gt;set-var&lt;/code&gt; dispatch is fairly straightforward. For the sake of brevity, you can either implement it on your own or find it in my git repo.  (TODO: link implementation here)&lt;/p&gt;&lt;h3 id=&quot;start&amp;#95;the&amp;#95;engine&amp;#95;d3.forcesimulation&quot;&gt;Start the engine d3.forceSimulation&lt;/h3&gt;&lt;p&gt;If you've already jumped the gun and tried to see what we have so far in the browser, you were probably dispointed to see that all the points are located on the upper left hand corner of the screen. In order to see all the nodes and edges rendered at their appropriate locations, we'll need to pass the previously constructed nodes and link elements into &lt;code&gt;d3.forceSimulation&lt;/code&gt;, and we'll achieve this as a &lt;code&gt;:raw&lt;/code&gt; piece.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; pieces
&amp;#91;
;; :elem-with-data for nodes &amp;#40;see the previous code snippet&amp;#41;
...
;; :elem-with-data for links &amp;#40;see the previous code snippet&amp;#41;
...
{:kind :raw
 :did-mount sim-did-update
 :did-update sim-did-update
}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn sim-did-update &amp;#91;ratom&amp;#93;
  &amp;#40;let &amp;#91;sim &amp;#40;-&amp;gt; &amp;#40;js/d3.forceSimulation&amp;#41;
                &amp;#40;.force &amp;quot;link&amp;quot; &amp;#40;.id &amp;#40;-&amp;gt; js/d3 .forceLink&amp;#41; &amp;#40;fn &amp;#91;d&amp;#93; &amp;#40;.-id d&amp;#41;&amp;#41;&amp;#41;&amp;#41;
                &amp;#40;.force &amp;quot;charge&amp;quot; &amp;#40;js/d3.forceManyBody&amp;#41;&amp;#41;
                &amp;#40;.force &amp;quot;center&amp;quot; &amp;#40;js/d3.forceCenter &amp;#40;/ &amp;#40;:width @ratom&amp;#41; 2&amp;#41;
                                                    &amp;#40;/ &amp;#40;:height @ratom&amp;#41; 2&amp;#41;&amp;#41;&amp;#41;&amp;#41;
        node-dataset &amp;#40;clj-&amp;gt;js &amp;#40;-&amp;gt; @ratom
                                  &amp;#40;get :dataset&amp;#41;
                                  &amp;#40;get :nodes&amp;#41;&amp;#41;&amp;#41;
        link-dataset &amp;#40;clj-&amp;gt;js &amp;#40;-&amp;gt; @ratom
                                  &amp;#40;get :dataset&amp;#41;
                                  &amp;#40;get :links&amp;#41;&amp;#41;&amp;#41;
        node-elems @&amp;#40;re-frame/subscribe &amp;#91;:get-var :node-elems&amp;#93;&amp;#41;
        link-elems @&amp;#40;re-frame/subscribe &amp;#91;:get-var :link-elems&amp;#93;&amp;#41;

        tick-handler &amp;#40;fn &amp;#91;&amp;#93;
                       &amp;#40;-&amp;gt; node-elems
                           &amp;#40;.attr &amp;quot;cx&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;.-x &amp;#40;get node-dataset idx&amp;#41;&amp;#41;&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;cy&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;.-y &amp;#40;get node-dataset idx&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

                       &amp;#40;-&amp;gt; link-elems
                           &amp;#40;.attr &amp;quot;x1&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;-&amp;gt; &amp;#40;get link-dataset idx&amp;#41;
                                             .-source .-x&amp;#41;&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;y1&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;-&amp;gt; &amp;#40;get link-dataset idx&amp;#41;
                                             .-source .-y&amp;#41;&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;x2&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;		
                                         &amp;#40;-&amp;gt; &amp;#40;get link-dataset idx&amp;#41;
                                             .-target .-x&amp;#41;&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;y2&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;-&amp;gt; &amp;#40;get link-dataset idx&amp;#41;
                                             .-target .-y&amp;#41;&amp;#41;&amp;#41;
                           &amp;#41;&amp;#41;
        &amp;#93;
    ;; Add notes to simulation
    &amp;#40;-&amp;gt; sim
        &amp;#40;.nodes node-dataset&amp;#41;
        &amp;#40;.on &amp;quot;tick&amp;quot; tick-handler&amp;#41;&amp;#41;

    ;; Add link force to simulation
    &amp;#40;-&amp;gt; sim
        &amp;#40;.force &amp;quot;link&amp;quot;&amp;#41;
        &amp;#40;.links link-dataset&amp;#41;&amp;#41;
    &amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the beginning of the &lt;code&gt;sim-did-update&lt;/code&gt; function, we create a &lt;code&gt;forceSimulation&lt;/code&gt; instance. To really get the simulation started, we'll need to add the link force and the nodes to the &lt;code&gt;forceSimulation&lt;/code&gt; instance and update the new positions for the node and link elements on every tick.&lt;/p&gt;&lt;p&gt;As alluded to in the earlier section, we'll retrieve the previously created node and link elements from &lt;code&gt;reframe/subscribe&lt;/code&gt;. Once again the &lt;code&gt;:get-var&lt;/code&gt; subscription should be fairly straightforward to implement. As always, you can take a look the actual code in github.&lt;/p&gt;&lt;p&gt;One thing that I'd like to point out here is that the new coordinates will get assigned to the &lt;code&gt;ratom&lt;/code&gt;, namely &lt;code&gt;&amp;#40;-&amp;gt; @ratom &amp;#40;get :dataset&amp;#41; &amp;#40;get :nodes&amp;#41;&amp;#41;&lt;/code&gt; and  &lt;code&gt;&amp;#40;-&amp;gt; @raom &amp;#40;get :dataset&amp;#41; &amp;#40;get :links&amp;#41;&amp;#41;&lt;/code&gt; by the d3 simulation engine. Both &lt;code&gt;node-dataset&lt;/code&gt; and &lt;code&gt;link-dataset&lt;/code&gt; must be converted to javascript objects or it won't work.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;//img/d3-force-directed-1.png&quot; alt=&quot;d3 force directed graph in cljs&quot; /&gt;&lt;/p&gt;&lt;p&gt;Voila!&lt;/p&gt;&lt;h3 id=&quot;making&amp;#95;it&amp;#95;draggable&quot;&gt;Making it draggable&lt;/h3&gt;&lt;p&gt;D3 itself already provides a nice API for drag and drop. We'll need to invoke D3's drag api with our &lt;code&gt;node-elements&lt;/code&gt;.&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;-&amp;gt; node
  &amp;#40;.attr &amp;quot;r&amp;quot; &amp;#40;fn &amp;#91;d&amp;#93;
               5&amp;#41;&amp;#41;
  &amp;#40;.attr &amp;quot;fill&amp;quot; &amp;#40;fn &amp;#91;n&amp;#93;
                  &amp;quot;red&amp;quot;&amp;#41;&amp;#41;
  &amp;#40;.call &amp;#40;-&amp;gt; js/d3                        ;; &amp;lt;------ add this block of code
             &amp;#40;.drag&amp;#41;
             &amp;#40;.on &amp;quot;start&amp;quot; drag-started&amp;#41;
             &amp;#40;.on &amp;quot;drag&amp;quot; dragged&amp;#41;
             &amp;#40;.on &amp;quot;end&amp;quot; drag-ended&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;Now we'll need to define &lt;code&gt;drag-started&lt;/code&gt;, &lt;code&gt;dragged&lt;/code&gt;, and &lt;code&gt;drag-ended&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn drag-started &amp;#91;d idx&amp;#93;
  &amp;#40;let &amp;#91;sim @&amp;#40;re-frame/subscribe &amp;#91;:get-var :sim&amp;#93;&amp;#41;
        d &amp;#40;-&amp;gt; sim .nodes &amp;#40;get idx&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;when &amp;#40;= 0 &amp;#40;-&amp;gt; js/d3 .-event .-active&amp;#41;&amp;#41;
      &amp;#40;-&amp;gt; sim &amp;#40;.alphaTarget 0.3&amp;#41; &amp;#40;.restart&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;set! &amp;#40;.-fx d&amp;#41; &amp;#40;.-x d&amp;#41;&amp;#41;
    &amp;#40;set! &amp;#40;.-fy d&amp;#41; &amp;#40;.-y d&amp;#41;&amp;#41;&amp;#41;&amp;#41;


&amp;#40;defn dragged &amp;#91;&amp;#95; idx&amp;#93;
  &amp;#40;let &amp;#91;sim @&amp;#40;re-frame/subscribe &amp;#91;:get-var :sim&amp;#93;&amp;#41;
        d &amp;#40;-&amp;gt; sim .nodes &amp;#40;get idx&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;set! &amp;#40;.-fx d&amp;#41; &amp;#40;.-x js/d3.event&amp;#41;&amp;#41;
    &amp;#40;set! &amp;#40;.-fy d&amp;#41; &amp;#40;.-y js/d3.event&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn drag-ended &amp;#91;&amp;#95; idx&amp;#93;
  &amp;#40;let &amp;#91;sim @&amp;#40;re-frame/subscribe &amp;#91;:get-var :sim&amp;#93;&amp;#41;
        d &amp;#40;-&amp;gt; sim .nodes &amp;#40;get idx&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;when &amp;#40;= 0 &amp;#40;-&amp;gt; js/d3 .-event .-active&amp;#41;&amp;#41;
      &amp;#40;-&amp;gt; sim &amp;#40;.alphaTarget 0&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;set! &amp;#40;.-fx d&amp;#41; nil&amp;#41;
    &amp;#40;set! &amp;#40;.-fy d&amp;#41; nil&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;						
</description>
<pubDate>
Sat, 13 Jan 2018 00:00:00 -0800
</pubDate>
</item>
</channel>
</rss>
