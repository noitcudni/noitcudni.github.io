<?xml version='1.0' encoding='UTF-8'?>
<rss version='2.0' xmlns:atom='http://www.w3.org/2005/Atom'>
<channel>
<atom:link href='https://noitcudni.github.io/' rel='self' type='application/rss+xml'/>
<title>
(polymorphic-labs/blog)
</title>
<link>
https://noitcudni.github.io/
</link>
<description>
Programming related stuff
</description>
<lastBuildDate>
Tue, 21 Apr 2020 22:02:08 -0700
</lastBuildDate>
<generator>
clj-rss
</generator>
<item>
<guid>
https://noitcudni.github.io/posts-output/2020-04-21-leetcode-spiral-print-matrix/
</guid>
<link>
https://noitcudni.github.io/posts-output/2020-04-21-leetcode-spiral-print-matrix/
</link>
<title>
Leetcode 54 - Spiral Matrix in Clojure
</title>
<description>
&lt;p&gt;Due to the entrenched interview process across the tech industry, every now and then I find myself needing to brush off my data structure/algorithm cob web prior to braving through another round of job interviews. Regardless of how many years of experience one has and ones domain knowledge, I believe that being at least familiar with the type of technical questions that might be presented during an interview is absolutely crucial.&lt;/p&gt;&lt;p&gt;On the other hand, I hate grinding through leetcode problems. If I have to do it, I might as well do it in a language I love. Some people out there may raise some concerns around using a non-mainstream language during an interview. I can attest that I did most of mine in clojure. Not only no one raised any objections, most were quite intrigued.&lt;/p&gt;&lt;p&gt;Leetcode is actually a good avenue to showcase the power and beauty of Clojure. Here I'll go over my approach to the problem step by step.&lt;/p&gt;&lt;p&gt;The following is the problem statement for &lt;a href=&quot;https://leetcode.com/problems/spiral-matrix/&quot;&gt;Spiral Matrix&lt;/a&gt;&lt;/p&gt;&lt;pre&gt;&lt;code&gt;Given a matrix of m x n elements (m rows, n columns),
return all elements of the matrix in spiral order.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We can easily solve this by extracting the first row, followed by rotating the remainder of the matrics counter-clockwise 90 degrees. Repeat, until we exhaust the entire matrix.&lt;/p&gt;&lt;p&gt;Let's assume that our input is a vector of vectors. For example,&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;[[1 2 3]
 [4 5 6]
 [7 8 9]]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Let's focus on the rotation alone first. The &quot;difficult&quot; part is to regroup the numbers vertically. We can easily map across all the nested vectors in lockstep and reorganize the numbers into a list or a vector.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(map vector
     [1 2 3]
     [4 5 6]
     [7 8 9])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Unfortunately, the input data is a vector of vectors. Only if we can unpack the top level vector, similar to Python's &lt;code&gt;*&lt;/code&gt; operator. This is exactly what &lt;code&gt;apply&lt;/code&gt; is for.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(apply map vector [[1 2 3]
                   [4 5 6]
                   [7 8 9]])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we just need them in the reverse order. This is trivial. Simply call &lt;code&gt;reverse&lt;/code&gt;&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(defn rotate [input]
  (reverse (apply map vector input))
  )

(rotate [[1 2 3]
         [4 5 6]
         [7 8 9]])
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;We'll use &lt;code&gt;loop&lt;/code&gt;/&lt;code&gt;recur&lt;/code&gt; to keep grabbing the first vector and rotate the rest until the input matrix withers away in front of our eyes.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(let [input [[1 2 3]
             [4 5 6]
             [7 8 9]]]
  (loop [[first-row &amp;amp; more-rows] input
         accum []]
    (if (nil? more-rows)
      (concat accum first-row)
      (recur (rotate more-rows) (concat accum first-row)))
    ))
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Just turn that into a function and we are done.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(defn spiral-print [input]
  (loop [[first-row &amp;amp; more-rows] input
         accum []]
    (if (nil? more-rows)
      (concat accum first-row)
      (recur (rotate more-rows) (concat accum first-row)))
    ))
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;klipse-cljs nohighlight&quot;&gt;(spiral-print [[1 2 3]
               [4 5 6]
               [7 8 9]])

&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Usually one needs to come up with space and time complexity in terms of big O. I'll leave that to you. You can find the code on my &lt;a href=&quot;https://github.com/noitcudni/leetcode-clojure-solution/blob/master/src/leetcode_clojure_solution/54_spiral_matrix.clj&quot;&gt;github repo&lt;/a&gt;.&lt;/p&gt;
</description>
<pubDate>
Tue, 21 Apr 2020 00:00:00 -0700
</pubDate>
</item>
<item>
<guid>
https://noitcudni.github.io/posts-output/2020-02-17-chrome-webstore-rejection/
</guid>
<link>
https://noitcudni.github.io/posts-output/2020-02-17-chrome-webstore-rejection/
</link>
<title>
How my Chrome extension finally got approved again
</title>
<description>
&lt;p&gt;My little Chrome &lt;a href=&quot;https://chrome.google.com/webstore/detail/webmaster-tools-bulk-url/pmnpibilljafelnghknefahibdnfeece&quot;&gt;extension&lt;/a&gt; has been on the Chrome Web Store since March 2018. I've never had any issues getting it approved until some time in January 2020.&lt;/p&gt;&lt;p&gt;I had to make significant improvements and bug fixes, so I was eager to release it. Typically, the turn around time was about 30 minutes to 24 hours. I pressed the publish button, expecting a usual quick turnaround, but this time I waited and waited. Finally, after 2.5 weeks, they sent me a rejection email stating that I needed to &quot;narrow&quot; the list of permissions my extension was asking the users. Fair enough. It did indeed have a few permissions that were no longer needed. I promptly made the corrections and resubmit.&lt;/p&gt;&lt;p&gt;Within 24 hours they sent me another rejection letter, but this time with a very vague reason and threatening tone. &lt;img src=&quot;../../img/chrome-webstore-rejection.png&quot; alt=&quot;spam rejection&quot; /&gt;&lt;/p&gt;&lt;p&gt;What? I have at least 700+ paying customers. How was my extension suddenly spam? The worst of all it states that my extension was removed from the Chrome Web Store. Thankfully, it simply rejected my latest submission. I replied back and asked for more clarifications, but no one ever got back to me. Now my only option is just tweaking a bit here and there and resubmit. Every time I would get the same aforementioned rejection email.&lt;/p&gt;&lt;p&gt;After days of bewilderment, while poking around on my Chrome Web Store Developer page, I decided to go through the bunched up yellow notification boxes which I typically ignore, and I noticed that there's a new developer dashboard. &lt;img src=&quot;../../img/new-developer-dashboard-notification.png&quot; alt=&quot;new developer dashboard notification&quot; /&gt;&lt;/p&gt;&lt;p&gt;The new developer dashboard pretty much is the exact same thing as the old one, except there's a privacy section. Inside the privacy section, they ask a bunch of questions about the extension. For example, permission justification; was I using remote code, etc. Having dutifully answered all the questions, I gave the Publish button another press.&lt;/p&gt;&lt;p&gt;After another 24 hours, I finally received an approval email!&lt;/p&gt;&lt;p&gt;In short, go to your old developer page. Find the link to your new developer dashboard (beta) page amongst all the yellow notification boxes. Go to the privacy section and answer all the questions. Press the Publish button.&lt;/p&gt;&lt;p&gt;Good luck.&lt;/p&gt;
</description>
<pubDate>
Mon, 17 Feb 2020 00:00:00 -0800
</pubDate>
</item>
<item>
<guid>
https://noitcudni.github.io/posts-output/2018-12-01-workingpoint-ios-app/
</guid>
<link>
https://noitcudni.github.io/posts-output/2018-12-01-workingpoint-ios-app/
</link>
<title>
An iOS invoicing app built specifically for WorkingPoint
</title>
<description>
&lt;p&gt;When it comes to accounting/bookkeeping software, in my opinion, WorkingPoint is the best bang for the buck. I have been using WorkingPoint since 2014 to keep track of my S Corp revenue, expenses, and to send my customers invoices. At the end of the year, I can generate a balance sheet and a cash flow statement with a click of a button and send those reports to my accountant. All that for a grand total of $99/year. I'm pretty confident that you can't find another solution at that price point. OK, I suppose that you can track everything in a spreadsheet, but that's not my cup of tea.&lt;/p&gt;&lt;p&gt;Unfortunately, its banking integration with my bank somehow stopped working about 2 years ago, which led to many frustrations. It caused me so much pain that I almost gave up on them entirely. Instead, I spent a weekend writing a Chrome extension to import expenses from my bank statement. That's a post for another day.&lt;/p&gt;&lt;p&gt;Today I'll focus on another major flaw with the product: it does not have a mobile solution of any kind. There's no native app nor is their web solution optimized for mobile. So, I took the matter into my own hand again and wrote an iOS app specifically for WorkingPoint with &lt;a href='https://github.com/drapanjanas/re-natal'&gt;re-natal&lt;/a&gt; (basically, react native but in Clojurescript). In layman's term, this will provide the user with a native app experience. After months of working it on the side plus another month of dealing with Apple's approval process, it's finally live. You can find it here: https://itunes.apple.com/us/app/invoice-puppy/id1438335818?ls=1&amp;mt=8. The name of my app is Invoice Puppy. I figured why not have a cute animal as the face of my app.&lt;/p&gt;&lt;p&gt;Sorry, it doesn't do all the things that Workingpoint website does. My only goal was to be able to create invoices and quotes and to perform other peripheral functions related to invoicing, such as contact and item creation. Also, you can email your customer the invoice directly from the app. The following is several screenshots of the app.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/invoice-puppy/300x0w.png&quot; alt=&quot;list of invoices&quot; /&gt; &lt;img src=&quot;../../img/invoice-puppy/300x0w&amp;#40;1&amp;#41;.png&quot; alt=&quot;list of customers&quot; /&gt;&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/invoice-puppy/300x0w&amp;#40;2&amp;#41;.png&quot; alt=&quot;email invoice&quot; /&gt; &lt;img src=&quot;../../img/invoice-puppy/300x0w&amp;#40;3&amp;#41;.png&quot; alt=&quot;invoice creation&quot; /&gt;&lt;/p&gt;&lt;p&gt;I've decided to sell the app for $19.99. I've done a bunch of testing, but I'm sure that there are still bugs. Should you run into any issues, please feel free to file an issue on &lt;a href='https://github.com/noitcudni/invoice-puppy-workingpoint/issues'&gt;here&lt;/a&gt;. I'll address them in a timely manner.&lt;/p&gt;
</description>
<pubDate>
Sat, 01 Dec 2018 00:00:00 -0800
</pubDate>
</item>
<item>
<guid>
https://noitcudni.github.io/posts-output/2018-10-22-bulk-google-webmaster-outdated-content-removal/
</guid>
<link>
https://noitcudni.github.io/posts-output/2018-10-22-bulk-google-webmaster-outdated-content-removal/
</link>
<title>
Chrome Extension: Bulk Google Webmaster Outdated Content Removal
</title>
<description>
&lt;p&gt;My little &lt;a href='https://github.com/noitcudni/google-webmaster-tools-bulk-url-removal'&gt;Google Webmaster Tool Bulk URL Removal chrome extension&lt;/a&gt; has gained quite a bit of usage. Several of those users have brought to my attention that Google Webmaster Tools also provides a way to remove outdated content, but it has a similar shortcoming: you can only remove outdated URLs one at a time. Recently, after wrapping up another side project, I decided to take a quick stab at this. You can find my extension here: &lt;a href='https://github.com/noitcudni/google-webmaster-tools-bulk-outdated-content-removal'&gt;https://github.com/noitcudni/google-webmaster-tools-bulk-outdated-content-removal&lt;/a&gt;.&lt;/p&gt;&lt;ul&gt;&lt;li&gt;Download the zip from github&lt;img src=&quot;//img/github-download-zip.png&quot; alt=&quot;Download the zip file from github&quot; /&gt;&lt;/li&gt;&lt;li&gt;Unzip it somewhere.&lt;/li&gt;&lt;li&gt;Go to &lt;code&gt;chrome://extensions/&lt;/code&gt; inside your chrome browser and turn on developer mode.&lt;/li&gt;&lt;li&gt;Click on &lt;code&gt;Load unpacked extension&lt;/code&gt; and load the extension.&lt;/li&gt;&lt;li&gt;Create a CSV file with the outdated URLs. For example:&lt;pre&gt;&lt;code&gt;http://out.dated.1.com/?foo=bar
http://out.dated.1.com/?foo=baz
http://out.dated.2.com/?foo=baz
&lt;/li&gt;&lt;/ul&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;&lt;li&gt;Go to https://www.google.com/webmasters/tools/removals and you should now have a &quot;Upload Your File&quot; button. Please note that the extension button next to your address bar doesn't do anything, so don't click on it. Click on the &quot;Upload Your File&quot; button and select the csv file you created in step 5.&lt;img src=&quot;//img/upload-your-file-screenshot.png&quot; alt=&quot;Upload your file to start bulk outdated content removals&quot; /&gt;&lt;/li&gt;&lt;/ul&gt;
</description>
<pubDate>
Mon, 22 Oct 2018 00:00:00 -0700
</pubDate>
</item>
<item>
<guid>
https://noitcudni.github.io/posts-output/2018-01-13-reagent-d3-force-directed-graph/
</guid>
<link>
https://noitcudni.github.io/posts-output/2018-01-13-reagent-d3-force-directed-graph/
</link>
<title>
Force-directed graph with D3js in Clojurescript
</title>
<description>
&lt;p&gt;Recently, I stumbled upon opensecrets.org where I could get a hold of raw data on US Senate and House campaign contributions. Full disclosure, I don't consider myself very political, nor do I know the interworkings of our political system, but I thought why not graph the contribution data in d3js.&lt;/p&gt;&lt;p&gt;I have done a couple d3js projects in the past in Javascript, but I really don't want to code in Javascript if I can help it. After some googling, I found &lt;a href='https://github.com/gadfly361/rid3'&gt;rid3&lt;/a&gt;, a clojurescript library on top of d3 and Reagent, and decided to give it a spin. I'm going to assume that you already have a working knowledge of reagent and re-frame.&lt;/p&gt;&lt;h3 id=&quot;setup&quot;&gt;Setup&lt;/h3&gt;&lt;p&gt;Add two additional dependencies to your project.clj. We're going to using re-frame for our state management.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defproject viz &amp;quot;0.1.0-SNAPSHOT&amp;quot;
  :dependencies &amp;#91;&amp;#91;org.clojure/clojure &amp;quot;1.8.0&amp;quot;&amp;#93;
                 &amp;#91;org.clojure/clojurescript &amp;quot;1.9.908&amp;quot;&amp;#93;
                 &amp;#91;reagent &amp;quot;0.7.0&amp;quot;&amp;#93;
                 &amp;#91;re-frame &amp;quot;0.10.2&amp;quot;&amp;#93; ;; &amp;lt;-- add this
                 &amp;#91;rid3 &amp;quot;0.2.0&amp;quot;&amp;#93;&amp;#93;  ;; &amp;lt;-- add this
                 ...
                 &amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;test&amp;#95;data&quot;&gt;Test data&lt;/h3&gt;&lt;p&gt;Apparently, there's a lot of data around campaign contributions. Instead of dealing with a large data set right off the bat while trying to get a d3 force-directed graph working in clojurescript, I decided it'd be wise to create a small data sample in order to iterate quickly.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; in db.cljs
&amp;#40;def default-db
  {:name &amp;quot;re-frame name&amp;quot;
   :test-data {:dataset
               {:nodes
                &amp;#91;{ :id &amp;quot;mammal&amp;quot; :group 0  :label &amp;quot;Mammals&amp;quot; :level 1 }
                 { :id &amp;quot;dog&amp;quot;    :group 0  :label &amp;quot;Dogs&amp;quot;    :level 2 }
                 { :id &amp;quot;cat&amp;quot;    :group 0  :label &amp;quot;Cats&amp;quot;    :level 2 }
                 { :id &amp;quot;fox&amp;quot;    :group 0  :label &amp;quot;Foxes&amp;quot;   :level 2 }
                 { :id &amp;quot;elk&amp;quot;    :group 0  :label &amp;quot;Elk&amp;quot;     :level 2 }
                 { :id &amp;quot;insect&amp;quot; :group 1  :label &amp;quot;Insects&amp;quot; :level 1 }
                 { :id &amp;quot;ant&amp;quot;    :group 1  :label &amp;quot;Ants&amp;quot;    :level 2 }
                 { :id &amp;quot;bee&amp;quot;    :group 1  :label &amp;quot;Bees&amp;quot;    :level 2 }
                 { :id &amp;quot;fish&amp;quot;   :group 2  :label &amp;quot;Fish&amp;quot;    :level 1 }
                 { :id &amp;quot;carp&amp;quot;   :group 2  :label &amp;quot;Carp&amp;quot;    :level 2 }
                 { :id &amp;quot;pike&amp;quot;   :group 2  :label &amp;quot;Pikes&amp;quot;   :level 2 }&amp;#93;
                :links
                &amp;#91;{ :target &amp;quot;mammal&amp;quot; :source &amp;quot;dog&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;mammal&amp;quot; :source &amp;quot;cat&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;mammal&amp;quot; :source &amp;quot;fox&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;mammal&amp;quot; :source &amp;quot;elk&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;insect&amp;quot; :source &amp;quot;ant&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;insect&amp;quot; :source &amp;quot;bee&amp;quot;  :strength 0.7 }
                 { :target &amp;quot;fish&amp;quot;   :source &amp;quot;carp&amp;quot; :strength 0.7 }
                 { :target &amp;quot;fish&amp;quot;   :source &amp;quot;pike&amp;quot; :strength 0.7 }
                 { :target &amp;quot;cat&amp;quot;    :source &amp;quot;elk&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;carp&amp;quot;   :source &amp;quot;ant&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;elk&amp;quot;    :source &amp;quot;bee&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;dog&amp;quot;    :source &amp;quot;cat&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;fox&amp;quot;    :source &amp;quot;ant&amp;quot;  :strength 0.1 }
                 { :target &amp;quot;pike&amp;quot;   :source &amp;quot;dog&amp;quot;  :strength 0.1 }
                 &amp;#93;}}}&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now we'll need to subscribe to the data, so we have a way to get a hold of it. In &lt;code&gt;subs.cljs&lt;/code&gt;, add a new subscription.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;re-frame/reg-sub
 ::data
 &amp;#40;fn &amp;#91;db&amp;#93;
   &amp;#40;:test-data db&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&quot;empty&amp;#95;canvas&quot;&gt;Empty Canvas&lt;/h3&gt;&lt;p&gt;In your views.cljs, create a &lt;code&gt;force-viz&lt;/code&gt; reagent component and render it inside the &lt;code&gt;main-panel&lt;/code&gt; function. Before rendering &lt;code&gt;force-viz&lt;/code&gt;, we'll also need to subscribe to &lt;code&gt;&amp;#91;::subs/data&amp;#93;&lt;/code&gt; and pass the result along.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn force-viz &amp;#91;ratom&amp;#93;
  &amp;#91;rid3/viz
    {:id &amp;quot;force&amp;quot;
     :ratom ratom
     :svg {:did-mount &amp;#40;fn &amp;#91;node ratom&amp;#93;
                        &amp;#40;-&amp;gt; node
                            &amp;#40;.attr &amp;quot;width&amp;quot; 1000&amp;#41;
                            &amp;#40;.attr &amp;quot;height&amp;quot; 1000&amp;#41;
                            &amp;#40;.style &amp;quot;background-color&amp;quot; &amp;quot;grey&amp;quot;&amp;#41;&amp;#41;&amp;#41;}
    }&amp;#93;&amp;#41;

&amp;#40;defn main-panel &amp;#91;&amp;#93;
  &amp;#40;fn &amp;#91;&amp;#93;
    &amp;#40;let &amp;#91;data &amp;#40;re-frame/subscribe &amp;#91;::subs/data&amp;#93;&amp;#41;&amp;#93;
      &amp;#91;force-viz data&amp;#93;
      &amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;This creates a big empty 1000 x 1000 canvas. Nothing too interesting at the moment. Let's make the width and height dynamically grow with the browser window. This is where &lt;code&gt;reagent&lt;/code&gt; really shines. On window resize, we are going to set the new height and width via &lt;code&gt;re-frame&lt;/code&gt;. If we have our &lt;code&gt;re-frame&lt;/code&gt; dispatch calls set up properly, our previous &lt;code&gt;re-frame&lt;/code&gt; subscription will automatically include the updated width and height dimensions.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;re-frame/reg-event-fx
 :window-width
 &amp;#40;fn &amp;#91;{:keys &amp;#91;db&amp;#93;} &amp;#91;&amp;#95; width&amp;#93;&amp;#93;
   {:db &amp;#40;-&amp;gt; db
            &amp;#40;assoc-in &amp;#91;:test-data :width&amp;#93; width&amp;#41;&amp;#41;}&amp;#41;&amp;#41;

;; I'll leave out the :window-height dispatch.
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Inside our &lt;code&gt;init&lt;/code&gt; function in &lt;code&gt;core.cljs&lt;/code&gt;, invoke &lt;code&gt;re-frame&lt;/code&gt; dispatch with the new dimensions.&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;set! js/window.onresize &amp;#40;fn &amp;#91;&amp;#93;
                             &amp;#40;re-frame/dispatch &amp;#91;:window-width js/window.innerWidth&amp;#93;&amp;#41;
                             &amp;#40;re-frame/dispatch &amp;#91;:window-height js/window.innerHeight&amp;#93;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;Don't forget to get rid of the hardcoded 1000x1000 pixels.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn force-viz &amp;#91;ratom&amp;#93;
  &amp;#91;rid3/viz
   {:id &amp;quot;force&amp;quot;
    :ratom ratom
    :svg {:did-mount &amp;#40;fn &amp;#91;node ratom&amp;#93;
                       &amp;#40;.log js/console &amp;quot;here? &amp;quot; &amp;#40;pr-str @ratom&amp;#41;&amp;#41;
                       &amp;#40;-&amp;gt; node
                           &amp;#40;.attr &amp;quot;width&amp;quot; &amp;#40;:width @ratom&amp;#41;&amp;#41;  &amp;lt;-- change here
                           &amp;#40;.attr &amp;quot;height&amp;quot; &amp;#40;:height @ratom&amp;#41;&amp;#41; &amp;lt;-- change here
                           &amp;#40;.style &amp;quot;background-color&amp;quot; &amp;quot;grey&amp;quot;&amp;#41;&amp;#41;&amp;#41;
          }}
    :pieces
    &amp;#91;
    ... ;; &amp;lt;--- more on this below
    &amp;#93;
          &amp;#93;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Now whenever &lt;code&gt;ratom&lt;/code&gt; changes, &lt;code&gt;force-viz&lt;/code&gt; will be rendered automatically.&lt;/p&gt;&lt;h3 id=&quot;let's&amp;#95;draw&amp;#95;some&amp;#95;nodes&amp;#95;and&amp;#95;edges&quot;&gt;Let's draw some nodes and edges&lt;/h3&gt;&lt;p&gt;Quick background. There are 4 types of &lt;code&gt;:pieces&lt;/code&gt; in rid3: &lt;code&gt;elem&lt;/code&gt;, &lt;code&gt;elem-with-data&lt;/code&gt;, &lt;code&gt;container&lt;/code&gt;, and &lt;code&gt;raw&lt;/code&gt;. The order of execution is sequential from top to bottom in &lt;code&gt;:pieces&lt;/code&gt;.&lt;/p&gt;&lt;p&gt;In most cases, bootstrapping and updating in d3 are done in the same manner. By default, rid3's &lt;code&gt;did-update&lt;/code&gt; lifecycle does the same thing as &lt;code&gt;did-mount&lt;/code&gt; unless you tell it otherwise. However, it's worth noting that you have to supply both &lt;code&gt;:did-mount&lt;/code&gt; and &lt;code&gt;:did-update&lt;/code&gt; for the &lt;code&gt;:raw&lt;/code&gt; piece.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; pieces
&amp;#91;{:kind :elem-with-data
  :tag &amp;quot;circle&amp;quot;
  :class &amp;quot;node&amp;quot;
  :did-mount &amp;#40;fn &amp;#91;node ratom&amp;#93;
               &amp;#40;let &amp;#91;r &amp;#40;-&amp;gt; node
                           &amp;#40;.attr &amp;quot;r&amp;quot; &amp;#40;fn &amp;#91;d&amp;#93;
                                        5&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;fill&amp;quot; &amp;#40;fn &amp;#91;n&amp;#93;
                                           &amp;quot;red&amp;quot;&amp;#41;&amp;#41;&amp;#41;&amp;#93;
                 &amp;#40;re-frame/dispatch-sync &amp;#91;:set-var :node-elems r&amp;#93;&amp;#41;&amp;#41;&amp;#41;
  :prepare-dataset &amp;#40;fn &amp;#91;ratom&amp;#93;
                     &amp;#40;-&amp;gt; @ratom
                         &amp;#40;get :dataset&amp;#41;
                         &amp;#40;get :nodes&amp;#41;
                         clj-&amp;gt;js&amp;#41;&amp;#41;}

 {:kind :elem-with-data
  :tag &amp;quot;line&amp;quot;
  :class &amp;quot;link&amp;quot; ;;TODO customize link class
  :did-mount &amp;#40;fn &amp;#91;node ratom&amp;#93;
               &amp;#40;let &amp;#91;r &amp;#40;-&amp;gt; node
                           &amp;#40;.attr &amp;quot;stroke-width&amp;quot; 1&amp;#41;
                           &amp;#40;.attr &amp;quot;stroke&amp;quot; &amp;quot;#E5E5E5&amp;quot;&amp;#41;
                           &amp;#41;&amp;#93;
                 &amp;#40;re-frame/dispatch-sync &amp;#91;:set-var :link-elems r&amp;#93;&amp;#41;&amp;#41;&amp;#41;
  :prepare-dataset &amp;#40;fn &amp;#91;ratom&amp;#93;
                     &amp;#40;-&amp;gt; @ratom
                         &amp;#40;get :dataset&amp;#41;
                         &amp;#40;get :links&amp;#41;
                         clj-&amp;gt;js&amp;#41;&amp;#41;}

 &amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Instead of dealing with &lt;code&gt;enter&amp;#40;&amp;#41;&lt;/code&gt;, &lt;code&gt;exit&amp;#40;&amp;#41;&lt;/code&gt;, and binding the appropriate piece of data to a selected group of svg objects, most of the heavy lifting has already been done for us. We can turn our focus to how we'd like to represent the information. Since we have a nested structure in our data, we'll have to supply &lt;code&gt;:prepare-dataset&lt;/code&gt;. Hopefully, you would agree that it's pretty trivial.&lt;/p&gt;&lt;p&gt;In Javascript, one could create a bunch of node and link elements, assign them to their respective variables, and refer to them later when necessary. Spoiler alert, we'll need to somehow pass our newly constructed nodes and links to &lt;code&gt;d3.forceSimulation&lt;/code&gt; to kickstart the force directed graph. At first glance, there's no way of doing that with rid3. Don't despair. We can stash the node elements and the link elements via re-frame and get them back later. Hence, the &lt;code&gt;re-frame/dispatch-sync&lt;/code&gt; calls. Note that we'll need to call &lt;code&gt;dispatch-sync&lt;/code&gt; here and not &lt;code&gt;dispatch&lt;/code&gt; since we want to make sure that both node and link elements are done storing before going forward.&lt;/p&gt;&lt;p&gt;The implementation of &lt;code&gt;set-var&lt;/code&gt; dispatch is fairly straightforward. For the sake of brevity, you can either implement it on your own or find it in my git repo.  (TODO: link implementation here)&lt;/p&gt;&lt;h3 id=&quot;start&amp;#95;the&amp;#95;engine&amp;#95;d3.forcesimulation&quot;&gt;Start the engine d3.forceSimulation&lt;/h3&gt;&lt;p&gt;If you've already jumped the gun and tried to see what we have so far in the browser, you were probably dispointed to see that all the points are located on the upper left hand corner of the screen. In order to see all the nodes and edges rendered at their appropriate locations, we'll need to pass the previously constructed nodes and link elements into &lt;code&gt;d3.forceSimulation&lt;/code&gt;, and we'll achieve this as a &lt;code&gt;:raw&lt;/code&gt; piece.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;;; pieces
&amp;#91;
;; :elem-with-data for nodes &amp;#40;see the previous code snippet&amp;#41;
...
;; :elem-with-data for links &amp;#40;see the previous code snippet&amp;#41;
...
{:kind :raw
 :did-mount sim-did-update
 :did-update sim-did-update
}&amp;#93;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn sim-did-update &amp;#91;ratom&amp;#93;
  &amp;#40;let &amp;#91;sim &amp;#40;-&amp;gt; &amp;#40;js/d3.forceSimulation&amp;#41;
                &amp;#40;.force &amp;quot;link&amp;quot; &amp;#40;.id &amp;#40;-&amp;gt; js/d3 .forceLink&amp;#41; &amp;#40;fn &amp;#91;d&amp;#93; &amp;#40;.-id d&amp;#41;&amp;#41;&amp;#41;&amp;#41;
                &amp;#40;.force &amp;quot;charge&amp;quot; &amp;#40;js/d3.forceManyBody&amp;#41;&amp;#41;
                &amp;#40;.force &amp;quot;center&amp;quot; &amp;#40;js/d3.forceCenter &amp;#40;/ &amp;#40;:width @ratom&amp;#41; 2&amp;#41;
                                                    &amp;#40;/ &amp;#40;:height @ratom&amp;#41; 2&amp;#41;&amp;#41;&amp;#41;&amp;#41;
        node-dataset &amp;#40;clj-&amp;gt;js &amp;#40;-&amp;gt; @ratom
                                  &amp;#40;get :dataset&amp;#41;
                                  &amp;#40;get :nodes&amp;#41;&amp;#41;&amp;#41;
        link-dataset &amp;#40;clj-&amp;gt;js &amp;#40;-&amp;gt; @ratom
                                  &amp;#40;get :dataset&amp;#41;
                                  &amp;#40;get :links&amp;#41;&amp;#41;&amp;#41;
        node-elems @&amp;#40;re-frame/subscribe &amp;#91;:get-var :node-elems&amp;#93;&amp;#41;
        link-elems @&amp;#40;re-frame/subscribe &amp;#91;:get-var :link-elems&amp;#93;&amp;#41;

        tick-handler &amp;#40;fn &amp;#91;&amp;#93;
                       &amp;#40;-&amp;gt; node-elems
                           &amp;#40;.attr &amp;quot;cx&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;.-x &amp;#40;get node-dataset idx&amp;#41;&amp;#41;&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;cy&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;.-y &amp;#40;get node-dataset idx&amp;#41;&amp;#41;&amp;#41;&amp;#41;&amp;#41;

                       &amp;#40;-&amp;gt; link-elems
                           &amp;#40;.attr &amp;quot;x1&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;-&amp;gt; &amp;#40;get link-dataset idx&amp;#41;
                                             .-source .-x&amp;#41;&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;y1&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;-&amp;gt; &amp;#40;get link-dataset idx&amp;#41;
                                             .-source .-y&amp;#41;&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;x2&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;-&amp;gt; &amp;#40;get link-dataset idx&amp;#41;
                                             .-target .-x&amp;#41;&amp;#41;&amp;#41;
                           &amp;#40;.attr &amp;quot;y2&amp;quot; &amp;#40;fn &amp;#91;&amp;#95; idx&amp;#93;
                                         &amp;#40;-&amp;gt; &amp;#40;get link-dataset idx&amp;#41;
                                             .-target .-y&amp;#41;&amp;#41;&amp;#41;
                           &amp;#41;&amp;#41;
        &amp;#93;
    ;; Add notes to simulation
    &amp;#40;-&amp;gt; sim
        &amp;#40;.nodes node-dataset&amp;#41;
        &amp;#40;.on &amp;quot;tick&amp;quot; tick-handler&amp;#41;&amp;#41;

    ;; Add link force to simulation
    &amp;#40;-&amp;gt; sim
        &amp;#40;.force &amp;quot;link&amp;quot;&amp;#41;
        &amp;#40;.links link-dataset&amp;#41;&amp;#41;
    &amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;In the beginning of the &lt;code&gt;sim-did-update&lt;/code&gt; function, we create a &lt;code&gt;forceSimulation&lt;/code&gt; instance. To really get the simulation started, we'll need to add the link force and the nodes to the &lt;code&gt;forceSimulation&lt;/code&gt; instance and update the new positions for the node and link elements on every tick.&lt;/p&gt;&lt;p&gt;As alluded to in the earlier section, we'll retrieve the previously created node and link elements from &lt;code&gt;reframe/subscribe&lt;/code&gt;. Once again the &lt;code&gt;:get-var&lt;/code&gt; subscription should be fairly straightforward to implement. As always, you can take a look the actual code in github.&lt;/p&gt;&lt;p&gt;One thing that I'd like to point out here is that the new coordinates will get assigned to the &lt;code&gt;ratom&lt;/code&gt;, namely &lt;code&gt;&amp;#40;-&amp;gt; @ratom &amp;#40;get :dataset&amp;#41; &amp;#40;get :nodes&amp;#41;&amp;#41;&lt;/code&gt; and  &lt;code&gt;&amp;#40;-&amp;gt; @raom &amp;#40;get :dataset&amp;#41; &amp;#40;get :links&amp;#41;&amp;#41;&lt;/code&gt; by the d3 simulation engine. Both &lt;code&gt;node-dataset&lt;/code&gt; and &lt;code&gt;link-dataset&lt;/code&gt; must be converted to javascript objects or it won't work.&lt;/p&gt;&lt;p&gt;&lt;img src=&quot;../../img/d3-force-directed-1.png&quot; alt=&quot;d3 force directed graph in cljs&quot; /&gt;&lt;/p&gt;&lt;p&gt;Voila!&lt;/p&gt;&lt;h3 id=&quot;making&amp;#95;it&amp;#95;draggable&quot;&gt;Making it draggable&lt;/h3&gt;&lt;p&gt;D3 itself already provides a nice API for drag and drop. We'll need to invoke D3's drag api with our &lt;code&gt;node-elements&lt;/code&gt;.&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;-&amp;gt; node
  &amp;#40;.attr &amp;quot;r&amp;quot; &amp;#40;fn &amp;#91;d&amp;#93;
               5&amp;#41;&amp;#41;
  &amp;#40;.attr &amp;quot;fill&amp;quot; &amp;#40;fn &amp;#91;n&amp;#93;
                  &amp;quot;red&amp;quot;&amp;#41;&amp;#41;
  &amp;#40;.call &amp;#40;-&amp;gt; js/d3                        ;; &amp;lt;------ add this block of code
             &amp;#40;.drag&amp;#41;
             &amp;#40;.on &amp;quot;start&amp;quot; drag-started&amp;#41;
             &amp;#40;.on &amp;quot;drag&amp;quot; dragged&amp;#41;
             &amp;#40;.on &amp;quot;end&amp;quot; drag-ended&amp;#41;&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;&lt;/p&gt;&lt;p&gt;Now we'll need to define &lt;code&gt;drag-started&lt;/code&gt;, &lt;code&gt;dragged&lt;/code&gt;, and &lt;code&gt;drag-ended&lt;/code&gt;.&lt;/p&gt;&lt;pre&gt;&lt;code class=&quot;clojure&quot;&gt;&amp;#40;defn drag-started &amp;#91;d idx&amp;#93;
  &amp;#40;let &amp;#91;sim @&amp;#40;re-frame/subscribe &amp;#91;:get-var :sim&amp;#93;&amp;#41;
        d &amp;#40;-&amp;gt; sim .nodes &amp;#40;get idx&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;when &amp;#40;= 0 &amp;#40;-&amp;gt; js/d3 .-event .-active&amp;#41;&amp;#41;
      &amp;#40;-&amp;gt; sim &amp;#40;.alphaTarget 0.3&amp;#41; &amp;#40;.restart&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;set! &amp;#40;.-fx d&amp;#41; &amp;#40;.-x d&amp;#41;&amp;#41;
    &amp;#40;set! &amp;#40;.-fy d&amp;#41; &amp;#40;.-y d&amp;#41;&amp;#41;&amp;#41;&amp;#41;


&amp;#40;defn dragged &amp;#91;&amp;#95; idx&amp;#93;
  &amp;#40;let &amp;#91;sim @&amp;#40;re-frame/subscribe &amp;#91;:get-var :sim&amp;#93;&amp;#41;
        d &amp;#40;-&amp;gt; sim .nodes &amp;#40;get idx&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;set! &amp;#40;.-fx d&amp;#41; &amp;#40;.-x js/d3.event&amp;#41;&amp;#41;
    &amp;#40;set! &amp;#40;.-fy d&amp;#41; &amp;#40;.-y js/d3.event&amp;#41;&amp;#41;&amp;#41;&amp;#41;

&amp;#40;defn drag-ended &amp;#91;&amp;#95; idx&amp;#93;
  &amp;#40;let &amp;#91;sim @&amp;#40;re-frame/subscribe &amp;#91;:get-var :sim&amp;#93;&amp;#41;
        d &amp;#40;-&amp;gt; sim .nodes &amp;#40;get idx&amp;#41;&amp;#41;&amp;#93;
    &amp;#40;when &amp;#40;= 0 &amp;#40;-&amp;gt; js/d3 .-event .-active&amp;#41;&amp;#41;
      &amp;#40;-&amp;gt; sim &amp;#40;.alphaTarget 0&amp;#41;&amp;#41;&amp;#41;
    &amp;#40;set! &amp;#40;.-fx d&amp;#41; nil&amp;#41;
    &amp;#40;set! &amp;#40;.-fy d&amp;#41; nil&amp;#41;&amp;#41;&amp;#41;
&lt;/code&gt;&lt;/pre&gt;
</description>
<pubDate>
Sat, 13 Jan 2018 00:00:00 -0800
</pubDate>
</item>
</channel>
</rss>
